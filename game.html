<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Asche meines Dorfes — Ausführliche Erweiterung</title>
<style>
  :root{--accent:#c84b31;--ui-bg:rgba(8,8,8,0.55);--muted:#d7cec7}
  html,body{height:100%;margin:0;background:#030303;color:var(--muted);font-family:Inter,system-ui,Arial}
  canvas{display:block;width:100%;height:100vh}
  /* UI */
  .ui-top{position:fixed;left:12px;top:12px;background:var(--ui-bg);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);backdrop-filter:blur(6px)}
  .ui-right{position:fixed;right:12px;top:12px;background:var(--ui-bg);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);min-width:260px}
  .hud{position:fixed;right:12px;bottom:12px;background:var(--ui-bg);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  .bar{width:220px;height:12px;background:#1a1a1a;border-radius:8px;overflow:hidden}
  .bar > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#7b2a1f)}
  .inv-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
  .slot{height:56px;background:#0f0f0f;border-radius:8px;border:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center}
  .btn{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--muted);cursor:pointer}
  .centerTip{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.65);padding:12px;border-radius:10px;font-size:15px}
  .modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:min(940px,96vw);max-height:80vh;overflow:auto;background:rgba(6,6,6,0.95);border-radius:12px;padding:18px;border:1px solid rgba(255,255,255,0.04)}
  .tooltip{position:fixed;padding:6px 8px;background:#121212;border-radius:6px;border:1px solid rgba(255,255,255,0.04);font-size:13px}
  /* mobile */
  .touch-joystick{position:fixed;left:14px;bottom:14px;width:140px;height:140px;border-radius:50%;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center}
  .touch-stick{width:64px;height:64px;border-radius:50%;background:rgba(255,255,255,0.06)}
  .touch-actions{position:fixed;right:16px;bottom:26px;display:flex;flex-direction:column;gap:8px}
  .touch-action{width:66px;height:66px;border-radius:12px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center}
  @media (max-width:820px){ .ui-right{display:none} }
</style>
</head>
<body>
<canvas id="mainCanvas"></canvas>

<div class="ui-top">
  <div style="font-weight:700">Asche meines Dorfes — Ausführlich</div>
  <div style="font-size:13px;color:#bfb6ae">Modulare Architektur: Assets, Animationen, AI, VFX, Level-Scripting, Inventory</div>
</div>

<div class="ui-right">
  <div style="display:flex;justify-content:space-between;align-items:center"><div>Level</div><div id="levelName">Prolog</div></div>
  <div style="margin-top:8px">HP</div>
  <div class="bar" style="margin-top:6px"><i id="hpBar" style="width:100%"></i></div>
  <div style="margin-top:10px">Inventar</div>
  <div class="inv-grid" id="invGrid">
    <div class="slot" id="slot-0" data-slot="head">Kopf</div>
    <div class="slot" id="slot-1" data-slot="chest">Brust</div>
    <div class="slot" id="slot-2" data-slot="legs">Beine</div>
  </div>
  <div style="margin-top:10px;display:flex;gap:8px"><button class="btn" id="openInvBtn">Öffne Inventar</button><button class="btn" id="openLevelEditorBtn">Level-Editor</button></div>
</div>

<div class="hud">
  <div style="font-size:13px">Moves</div>
  <div style="display:flex;gap:8px;margin-top:8px">
    <button class="btn" id="btnLight">Light</button>
    <button class="btn" id="btnHeavy">Heavy</button>
    <button class="btn" id="btnParry">Parry</button>
  </div>
</div>

<div class="touch-joystick" id="joy"><div class="touch-stick" id="stick"></div></div>
<div class="touch-actions"><div class="touch-action" id="ta-light">L</div><div class="touch-action" id="ta-heavy">H</div><div class="touch-action" id="ta-parry">P</div></div>

<div class="centerTip" id="centerTip">Klicke oder tippe um das Spiel zu starten (Audio)</div>

<!-- Embedded level data: story-driven waves and triggers -->
<script id="levels-data" type="application/json">
{
  "levels": [
    {
      "id": "prolog",
      "name": "Prolog",
      "desc": "Rettung & Genesung. Keine Feinde, Fokus auf Tutorial und Rüstungs-Pickups.",
      "waves": [],
      "pickups": [
        {"type":"head","pos":[-6,0,-10]},
        {"type":"chest","pos":[4,0,-14]},
        {"type":"legs","pos":[10,0,-22]}
      ]
    },
    {
      "id":"training",
      "name":"Training",
      "desc":"Kleine Gruppen von Plünderern. Lehrreiche Wellen.",
      "waves":[
        {"delay":1,"enemies":[{"type":"raider","count":3}],"spawnArea":10},
        {"delay":12,"enemies":[{"type":"raider","count":4},{"type":"brute","count":1}],"spawnArea":12}
      ]
    },
    {
      "id":"arena",
      "name":"Arena",
      "desc":"Harte Kämpfe gegen stärkere Gladiatoren.",
      "waves":[{"delay":1,"enemies":[{"type":"raider","count":6},{"type":"assassin","count":2}],"spawnArea":18},{"delay":20,"enemies":[{"type":"brute","count":3},{"type":"raider","count":8}],"spawnArea":22}]
    },
    {
      "id":"fortress",
      "name":"Festung",
      "desc":"Finale. Ragnar wartet im Thronsaal.",
      "waves":[{"delay":1,"enemies":[{"type":"raider","count":10},{"type":"assassin","count":4}],"spawnArea":35}],
      "boss": {"type":"ragnar","pos":[0,0,-48]}
    }
  ],
  "enemyTypes":{
    "raider": {"hp":40,"speed":1.1},
    "brute": {"hp":90,"speed":0.8},
    "assassin": {"hp":28,"speed":1.6},
    "ragnar": {"hp":900,"speed":0.9}
  }
}
</script>

<!-- Three.js + loaders (global) -->
<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.155.0/examples/js/loaders/GLTFLoader.js"></script>

<!-- Main module: modular classes, detailed comments -->
<script type="module">
// -----------------------------------------------------------
// Asche meines Dorfes — Ausführliche Erweiterung (Modular)
// - AssetManager: glTF/model/texture loader with fallbacks
// - AnimationManager: AnimationMixer based state machine + crossfade
// - VFXManager: particle pool, hit/parry effects + screen shake
// - InventoryManager: drag/drop equip, tooltips, save/load
// - LevelManager: JSON-driven waves, spawn points, boss triggers
// - EnemyAI: simple behavior state machine (patrol/chase/attack/flee)
// - Input & Mobile: joystick smoothing, deadzone, action mapping
// - Game: orchestrates subsystems, handles main loop
// -----------------------------------------------------------

const canvas = document.getElementById('mainCanvas');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio);
const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0a0a0a); scene.fog = new THREE.FogExp2(0x000000, 0.02);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000); camera.position.set(0,3.2,6);
// lights
const hemi = new THREE.HemisphereLight(0xffeebb, 0x222233, 0.9); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffcc88, 0.9); dir.position.set(-5,10,5); scene.add(dir);
// ground
const ground = new THREE.Mesh(new THREE.PlaneGeometry(600,600), new THREE.MeshStandardMaterial({color:0x121212, metalness:0.2, roughness:1})); ground.rotation.x = -Math.PI/2; scene.add(ground);

// Basic utilities
function v3(a){ return new THREE.Vector3(a[0], a[1], a[2]); }
function randRange(min,max){return Math.random()*(max-min)+min}

// ---------------- AssetManager ----------------
class AssetManager{
  constructor(){ this.gltfLoader = new THREE.GLTFLoader(); this.cache = {}; }
  loadGLTF(url){
    if(!url) return Promise.resolve(null);
    if(this.cache[url]) return Promise.resolve(this.cache[url]);
    return new Promise((res,rej)=>{
      this.gltfLoader.load(url, gltf=>{ this.cache[url]=gltf; res(gltf); }, null, err=>{ console.warn('GLTF load failed',url); res(null); });
    });
  }
  // helper: create fallback mesh for player/enemy
  createFallback(type){
    if(type === 'player'){
      const g = new THREE.CapsuleGeometry(0.45,0.6,4,8); const m = new THREE.MeshStandardMaterial({color:0x7f7f7f}); const mesh = new THREE.Mesh(g,m); mesh.position.y = 1; return mesh;
    }
    const g = new THREE.BoxGeometry(0.9,1.8,0.6); const m = new THREE.MeshStandardMaterial({color:0x442211}); const mesh = new THREE.Mesh(g,m); mesh.position.y = 0.9; return mesh;
  }
}

// ---------------- AnimationManager ----------------
class AnimationManager{
  constructor(object3d){ this.root = object3d; this.mixer = object3d ? new THREE.AnimationMixer(object3d) : null; this.actions = {}; this.current = null; this.prev = null; }
  addClips(clips){ if(!this.mixer) return; clips.forEach(c=>{ this.actions[c.name] = this.mixer.clipAction(c); }); }
  play(name, fade=0.25){ if(!this.mixer) return; if(this.current === name) return; const next = this.actions[name]; if(!next){ console.warn('Anim not found',name); return; } next.reset(); next.play(); if(this.current && this.actions[this.current]){ this.actions[this.current].crossFadeTo(next, fade, false); } this.prev = this.current; this.current = name; }
  update(dt){ if(this.mixer) this.mixer.update(dt); }
}

// ---------------- VFXManager ----------------
class VFXManager{
  constructor(scene){ this.scene = scene; this.pool = []; this.temp = new THREE.Vector3(); }
  spawnHit(pos){ // small spark + brief light
    const size = 0.18 + Math.random()*0.12; const g = new THREE.PlaneGeometry(size,size);
    const m = new THREE.MeshBasicMaterial({color:0xffbb88,transparent:true,opacity:0.95,side:THREE.DoubleSide});
    const s = new THREE.Mesh(g,m); s.position.copy(pos); s.position.y += 1.1; s.lookAt(camera.position); this.scene.add(s);
    setTimeout(()=>{ this.scene.remove(s); }, 220);
    this.screenShake(0.06,80);
  }
  spawnParry(pos){ const g = new THREE.RingGeometry(0.5,0.72,32); const m = new THREE.MeshBasicMaterial({color:0x99ddff,transparent:true,opacity:0.85,side:THREE.DoubleSide}); const r = new THREE.Mesh(g,m); r.rotation.x = -Math.PI/2; r.position.copy(pos); r.position.y += 0.4; this.scene.add(r); setTimeout(()=>{ this.scene.remove(r); }, 350); this.screenShake(0.02,30); }
  screenShake(intensity, durationMs){ const start = performance.now(); const orig = camera.position.clone(); const tick = ()=>{ const t = performance.now(); const dt = (t - start); if(dt > durationMs) { camera.position.copy(orig); return; } const f = 1 - (dt/durationMs); camera.position.x = orig.x + (Math.random()*2-1)*intensity*f; camera.position.y = orig.y + (Math.random()*2-1)*intensity*f*0.4; requestAnimationFrame(tick); }; tick(); }
}

// ---------------- InventoryManager ----------------
class InventoryManager{
  constructor(){ this.slots = [null,null,null]; this.uiSlots = [document.getElementById('slot-0'),document.getElementById('slot-1'),document.getElementById('slot-2')]; this.setupUI(); }
  setupUI(){ this.uiSlots.forEach((el, idx)=>{ el.addEventListener('click', ()=>{ const item = this.slots[idx]; if(item){ if(confirm('Item entfernen? ' + item.id)){ this.slots[idx]=null; this.refresh(); saveGame(); } } }); el.addEventListener('pointerenter',(e)=>{ const s = this.slots[idx]; if(s) showTooltip(e.clientX,e.clientY, s.id + '\n' + s.desc); }); el.addEventListener('pointerleave',hideTooltip); }); document.getElementById('openInvBtn').addEventListener('click', ()=>{ this.openInventoryModal(); }); }
  add(item){ const map = {head:0,chest:1,legs:2}; const idx = map[item.slot]; if(this.slots[idx]) return false; this.slots[idx]=item; this.refresh(); saveGame(); return true; }
  has(slot){ const map = {head:0,chest:1,legs:2}; return !!this.slots[map[slot]]; }
  refresh(){ this.uiSlots.forEach((el,idx)=>{ const i = this.slots[idx]; el.style.background = i ? 'linear-gradient(90deg,var(--accent),#7b2a1f)' : '#0f0f0f'; el.textContent = i ? i.id : (idx===0?'Kopf':idx===1?'Brust':'Beine'); }); }
  openInventoryModal(){ const modal = document.createElement('div'); modal.className='modal'; modal.innerHTML = '<h3>Inventar</h3><p>Slots und Items:</p><div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px">' + ['Kopf','Brust','Beine'].map((s,idx)=>`<div style="padding:8px;border:1px solid rgba(255,255,255,0.04);border-radius:10px">${s}<div style="margin-top:8px">${this.slots[idx] ? this.slots[idx].id : 'leer'}</div></div>`).join('') + '</div><p style="margin-top:12px"><button id="closeInv">Schließen</button></p>';
    document.body.appendChild(modal); document.getElementById('closeInv').addEventListener('click', ()=> modal.remove()); }
}

// ---------------- LevelManager ----------------
class LevelManager{
  constructor(game){ this.game = game; this.levels = JSON.parse(document.getElementById('levels-data').textContent).levels; this.enemyTypes = JSON.parse(document.getElementById('levels-data').textContent).enemyTypes; }
  get current(){ return this.levels[this.game.state.levelIndex]; }
  startLevel(index){ this.game.state.levelIndex = Math.max(0, Math.min(this.levels.length-1, index)); document.getElementById('levelName').innerText = this.current.name; // spawn pickups
    if(this.current.pickups) this.current.pickups.forEach(p=> this.game.spawnPickup(v3(p.pos), p.type)); // schedule waves
    if(this.current.waves) this.scheduleWaves(this.current.waves); if(this.current.boss){ // boss spawns when conditions met later
    }
  }
  scheduleWaves(waves){ let time = 0; waves.forEach(w=>{ setTimeout(()=>{ this.spawnWave(w); }, (w.delay||time)*1000); time += (w.delay||10); }); }
  spawnWave(w){ const area = w.spawnArea||12; (w.enemies||[]).forEach(group=>{ for(let i=0;i<group.count;i++){ const theta = Math.random()*Math.PI*2; const r = randRange(6,area); const pos = new THREE.Vector3(Math.cos(theta)*r,0, -Math.random()*r - 6); const cfg = this.enemyTypes[group.type]; this.game.spawnEnemy(pos, cfg); } }); }
}

// ---------------- EnemyAI ----------------
class EnemyAI{
  constructor(entity, game){ this.entity = entity; this.game = game; this.state = 'idle'; this.attackCooldown = randRange(0.6,1.8); }
  update(dt){ if(this.entity.hp <= 0) return; const toPlayer = new THREE.Vector3().subVectors(this.game.player.mesh.position, this.entity.mesh.position); const dist = toPlayer.length(); toPlayer.normalize(); if(this.state === 'idle'){ if(dist < 18) this.state = 'chase'; }
    if(this.state === 'chase'){ if(dist > 1.8){ this.entity.mesh.position.addScaledVector(toPlayer, this.entity.speed * dt); } else { // in melee
        if(this.attackCooldown <= 0){ this.attackCooldown = randRange(0.8,1.6); // resolve attack
          if(this.game.player.state === 'parry' && this.game.player.attackTimer > 0.06){ // parried -> stagger
            this.entity.hp -= 18; this.entity.stagger = 0.6; this.game.vfx.spawnParry(this.entity.mesh.position);
          } else { this.game.applyDamageToPlayer(8); }
        }
      }
    }
    if(this.attackCooldown > 0) this.attackCooldown -= dt;
  }
}

// ---------------- Input & Mobile Controls ----------------
class InputManager{
  constructor(game){ this.game = game; this.keys = {}; window.addEventListener('keydown', e=>{ this.keys[e.key.toLowerCase()] = true; if(e.key === 'Shift') this.game.player.block = true; }); window.addEventListener('keyup', e=>{ this.keys[e.key.toLowerCase()] = false; if(e.key === 'Shift') this.game.player.block = false; }); // UI buttons
    document.getElementById('btnLight').addEventListener('click', ()=> this.game.player.trigger('light'));
    document.getElementById('btnHeavy').addEventListener('click', ()=> this.game.player.trigger('heavy'));
    document.getElementById('btnParry').addEventListener('click', ()=> this.game.player.trigger('parry'));
    document.getElementById('ta-light').addEventListener('pointerdown', ()=> this.game.player.trigger('light'));
    document.getElementById('ta-heavy').addEventListener('pointerdown', ()=> this.game.player.trigger('heavy'));
    document.getElementById('ta-parry').addEventListener('pointerdown', ()=> this.game.player.trigger('parry'));
    // joystick
    this.joy = {dx:0,dy:0,active:false}; const stick = document.getElementById('stick'); const joyEl = document.getElementById('joy'); let pointerId = null; stick.addEventListener('pointerdown', e=>{ stick.setPointerCapture(e.pointerId); this.joy.active=true; pointerId = e.pointerId; }); stick.addEventListener('pointermove', e=>{ if(!this.joy.active || e.pointerId !== pointerId) return; const rect = joyEl.getBoundingClientRect(); const cx = rect.left + rect.width/2; const cy = rect.top + rect.height/2; const dx = e.clientX - cx; const dy = e.clientY - cy; const r = rect.width/2 - 10; const nx = Math.max(-r, Math.min(r, dx)); const ny = Math.max(-r, Math.min(r, dy)); stick.style.transform = `translate(${nx}px, ${ny}px)`; this.joy.dx = nx / r; this.joy.dy = -ny / r; }); window.addEventListener('pointerup', e=>{ this.joy.active=false; stick.style.transform = 'translate(0,0)'; this.joy.dx=0; this.joy.dy=0; }); }
  getMovement(){ // keyboard OR joystick
    const forward = (this.keys['w']?1:0) - (this.keys['s']?1:0);
    const strafe = (this.keys['d']?1:0) - (this.keys['a']?1:0);
    if(Math.abs(this.joy.dx) > 0.05 || Math.abs(this.joy.dy) > 0.05) return {x:this.joy.dx,y:this.joy.dy};
    return {x:strafe,y:forward}; }
}

// ---------------- Player wrapper ----------------
class Player{
  constructor(game, mesh){ this.game = game; this.mesh = mesh; this.hp = 100; this.maxHp = 100; this.state = 'idle'; this.combo = []; this.lastClick = 0; this.attackTimer = 0; this.dodgeTimer = 0; this.block = false; }
  trigger(type){ const t = performance.now(); if(type === 'parry'){ this.state = 'parry'; this.attackTimer = 0.18; this.game.vfx.spawnParry(this.mesh.position); return; } if(t - this.lastClick < 650) this.combo.push(type); else this.combo = [type]; this.lastClick = t; if(this.combo.length === 1){ this.state = 'light'; this.attackTimer = 0.26; } else if(this.combo.length === 2){ this.state = 'heavy'; this.attackTimer = 0.42; } else { this.state = 'finisher'; this.attackTimer = 0.7; this.combo = []; } }
  update(dt, input){ // movement
    const mv = input.getMovement(); if(Math.abs(mv.x) > 0.02 || Math.abs(mv.y)>0.02){ const ang = Math.atan2(mv.x, mv.y); this.mesh.rotation.y = ang; const dir = new THREE.Vector3(Math.sin(ang),0,Math.cos(ang)); this.mesh.position.addScaledVector(dir, this.game.playerSpeed * dt); if(this.state === 'idle') this.state = 'moving'; } else { if(this.state === 'moving') this.state = 'idle'; }
    if(this.attackTimer > 0) this.attackTimer = Math.max(0, this.attackTimer - dt); else if(this.state !== 'idle' && this.state !== 'moving') this.state = 'idle'; if(this.dodgeTimer > 0) this.dodgeTimer = Math.max(0, this.dodgeTimer - dt);
  }
  takeDamage(dmg){ if(this.block) dmg = Math.round(dmg * 0.35); if(this.state === 'parry' && this.attackTimer > 0.06) dmg = Math.round(dmg*0.05); // armor mitigation
    let red = 0; if(this.game.inventory.has('chest')) red += 0.22; if(this.game.inventory.has('head')) red += 0.12; if(this.game.inventory.has('legs')) red += 0.08; const final = Math.max(1, Math.round(dmg * (1 - red))); this.hp -= final; document.getElementById('hpBar').style.width = Math.max(0,(this.hp/this.maxHp)*100) + '%'; if(this.hp <= 0) this.die(); }
  die(){ this.state = 'dead'; const tip = document.createElement('div'); tip.className='centerTip'; tip.innerText = 'Du bist gefallen.'; document.body.appendChild(tip); }
}

// ---------------- Game (orchestrator) ----------------
class Game{
  constructor(){ this.asset = new AssetManager(); this.vfx = new VFXManager(scene); this.levels = new LevelManager(this); this.inventory = new InventoryManager(); this.input = new InputManager(this); this.enemies = []; this.enemyAIs = []; this.spawnPoints = [new THREE.Vector3(8,0,-12), new THREE.Vector3(-8,0,-16), new THREE.Vector3(14,0,-20)]; this.playerSpeed = 6; this.state = {levelIndex:0}; this.initPlayer(); }
  initPlayer(){ const fallback = this.asset.createFallback('player'); scene.add(fallback); this.player = new Player(this, fallback); this.player.mesh.position.set(0,0,0); }
  spawnEnemy(pos, cfg){ const mesh = this.asset.createFallback('enemy'); mesh.position.copy(pos); scene.add(mesh); const ent = {mesh, hp:cfg.hp || 40, speed:cfg.speed||1.1, stagger:0}; this.enemies.push(ent); this.enemyAIs.push(new EnemyAI(ent, this)); }
  spawnPickup(pos, type){ // forward to pickups array
    const g = new THREE.BoxGeometry(0.5,0.5,0.5); const m = new THREE.MeshStandardMaterial({color:type==='potion'?0x55aaee:0xc84b31}); const mesh = new THREE.Mesh(g,m); mesh.position.copy(pos); mesh.position.y = 0.3; scene.add(mesh); // register as pickup
    this._pickups = this._pickups || []; this._pickups.push({mesh,type}); }
  applyDamageToPlayer(dmg){ this.player.takeDamage(dmg); }
  update(dt){ // update player
    this.player.update(dt, this.input);
    // update enemies
    for(let i=0;i<this.enemyAIs.length;i++){ this.enemyAIs[i].update(dt); }
    // pickups detection
    if(this._pickups){ for(let i=this._pickups.length-1;i>=0;i--){ const p = this._pickups[i]; if(p.mesh.position.distanceTo(this.player.mesh.position) < 1.6){ if(p.type === 'potion'){ this.player.hp = Math.min(this.player.maxHp, this.player.hp + 45); scene.remove(p.mesh); this._pickups.splice(i,1); } else { const added = this.inventory.add({id:p.type + '-v1', slot:p.type, desc:'Rüstungsstück: ' + p.type}); scene.remove(p.mesh); this._pickups.splice(i,1); } } } }
    // remove dead enemies
    for(let i=this.enemies.length-1;i>=0;i--){ if(this.enemies[i].hp <= 0){ scene.remove(this.enemies[i].mesh); this.enemies.splice(i,1); this.enemyAIs.splice(i,1); } }
  }
}

// ---------------- Initialization & Loop ----------------
const game = new Game(); // start level 0
game.levels.startLevel(0);

let last = performance.now()/1000;
function animate(){ const now = performance.now()/1000; const dt = Math.min(0.05, now - last); last = now; // update
  game.update(dt);
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

// HUD & UI small helpers
function showTooltip(x,y,txt){ let tt = document.getElementById('tooltip'); if(!tt){ tt = document.createElement('div'); tt.id='tooltip'; tt.className='tooltip'; document.body.appendChild(tt); } tt.style.left = (x+10)+'px'; tt.style.top = (y+10)+'px'; tt.innerText = txt; }
function hideTooltip(){ const tt = document.getElementById('tooltip'); if(tt) tt.remove(); }

// attach buttons
document.getElementById('openLevelEditorBtn').addEventListener('click', ()=>{ openLevelEditor(); });

// level editor (simple JSON editor for waves)
function openLevelEditor(){ const modal = document.createElement('div'); modal.className='modal'; const data = JSON.parse(document.getElementById('levels-data').textContent); modal.innerHTML = '<h3>Level Editor (JSON)</h3><textarea id="leveljson" style="width:100%;height:60vh;background:#0b0b0b;color:#ddd;border:1px solid rgba(255,255,255,0.04);padding:8px">' + JSON.stringify(data, null, 2) + '</textarea><p style="margin-top:8px"><button id="saveLevels">Speichern</button> <button id="closeEditor">Schließen</button></p>'; document.body.appendChild(modal); document.getElementById('closeEditor').addEventListener('click', ()=> modal.remove()); document.getElementById('saveLevels').addEventListener('click', ()=>{ const raw = document.getElementById('leveljson').value; try{ JSON.parse(raw); alert('OK — Daten sind valide. Du musst die Seite neu laden um Änderungen zu übernehmen.'); localStorage.setItem('aschedorf_levels', raw); }catch(e){ alert('JSON ungültig: ' + e.message); } }); }

// Load override of levels from storage if present
const stored = localStorage.getItem('aschedorf_levels'); if(stored) document.getElementById('levels-data').textContent = stored;

// start loop on user interaction (resume audio on mobile)
document.getElementById('centerTip').addEventListener('click', ()=>{ document.getElementById('centerTip').style.display='none'; if(window.AudioContext && window.AudioContext.state === 'suspended'){} // resume handled elsewhere
  animate(); });

// responsive
window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); });

// Expose game for debugging
window._game = game;

// Very detailed comments and extension points are present in the code above.
// Next steps you might want me to implement (I can do these next, ausführlich):
// - Animation integration: provide example glTF files and map animation names to state-machine
// - VFX polish: particles, temporal AA, lighting flashes
// - Robust AI: flocking, flanking, pathfinding (A* using navmesh)
// - Networking (co-op revenge) and save/quest persistence
// Tell me which of these I should implement next; ich baue es dann direkt ein.

</script>
</body>
</html>
